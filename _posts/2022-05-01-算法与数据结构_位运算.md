---
title:      算法与数据结构-位运算              # 标题 
date:       2022-05-01          # 时间
author:     vhwz                      # 作者
---


## 算法与数据结构 位运算

### 总结
#### 基础知识：原码,补码和反码

对于正数, 原码 = 反码 = 补码  
对于负数, 反码 = 原码的位取反,但是符号位不变, 补码 = 反码 + 1  
二进制最高位为符号位, 符号位为1表示负数  
性质: 加数字的补码等于减去这个数字  
6 - 3 = 6 + (-3)  


|:----:|:---------:|:------------:|:----------:|
| 数字  | 原码     |  反码         | 补码       |
| 6    | 0000 0110 | 0000 0110    | 0000 0110  |
| -3   | 1000 0011 | 1111 1100    | 1111 1101  |



#### 位运算技巧
python 中 ~n = -(n+1)

举例说明:  

5  = 0000 0000 0000 0000 0000 0000 0000 0101  
~5= 1111 1111 1111 1111 1111 1111 1111 1010  

由符号位可知,这是一个负数,负数是用补码表示的.  
要求原码,需要将补码取反+1, 可得 ~5 = -6  

异或运算的性质"  
交换律：`A ^ B = B ^ A;`  
结合律：`A ^ (B ^ C) = (A ^ B) ^ C;`  
恒等律：`X ^ 0 = X;`  
归零律：`X ^ X = 0;`  
自反：`A ^ B ^ B = A ^ 0 = A;`  
对于任意的 `X： X ^ (-1) = ~X；`  
如果 `A ^ B = C , A ^ B = C，B ^ C = A；`  

异或的应用:  
`1 ^ 1 = 0, 0 ^ 1 = 1`, 数字与0异或结果不变, 因此数字与1的位移异或可以用于数字的位取反  

去掉数字二进制表示中的最后一个1   
假设数字n = ...xxx1000  
则 n - 1 = ...xxx01111  
显然 n&(n-1)会把最低位的1置为0, 其他不变  
```python
n = n&(n-1)
```
获取二进制表示的最低位的 1
假设数字 n = 0...xxx1000
则      -n = 1...yyy0111 + 1
           = 1...yyy1000
其中y与x相反
显然 n&(-n)之后只有n最低位的1被保留下来

```python
n = n&(-n)
```
进制转换问题
#### 尾随0问题
一串数字的乘积的尾随0都是由数字10与其他数字相乘得到的.  
根据算数基本定理,可以把数字分解为质数的乘积.  
其中数字10只能由2*5 = 10得到.尾随0一旦出现就不会消失.因此统计尾随0的数量等价与统计数字分解之后2,5的数量.  

#### 数论问题
算数基本定理  
任何大于1的数字都可被分解为质数的乘积  
 
同余定理  
(a - b)%k == 0 <==> a%k == b%k  

#### 数位DP问题
数位DP: 针对数字的位进行的DP

#### 快速幂问题
利用分治法减少运算次数

### 数字的位操作
#### 7. 整数反转

```python
def reverse(self, x: int) -> int:
    ans = 0
    neg = False
    if x < 0:
        neg = True
        x = abs(x)
    while x > 0:
        ans = ans*10 + x%10
        x = x//10
    if neg:
        ans = - ans
    if -2**31 <= ans <= 2**31 - 1:
        return ans 
    return 0
```

如果不允许使用 64 位整数

#### 9. 回文数
对python来说,这是一个简单的问题,直接返回str(num) == str(num)[::-1]  
或者利用上一题翻转整数后判断 num == reverse(num)  

#### 479. 最大回文数乘积

```python
def largestPalindrome(self, n: int) -> int:
    if n == 1:
        return 9
    def palindrome(n):
        #generate paildorme with 2*n digits
        for x in range(10**n-1, 10**(n-1), -1):
            yield int(str(x) + str(x)[::-1])
    def check(num):
        k = 10**n - 1
        while k*k >= num:
            if num%k == 0 and len(str(num//k)) == n:
                return True
            k -= 1
        return False
    for num in palindrome(n):
        if check(num):
            return num%1337
    return -1          
```             

#### 564. 寻找最近的回文数
构造出几种可能的答案, 再选择符合要求的一个  
假设n是L位数,  
如果最近的回文数不是L位数, 那么只可能是$10**L + 1, 10**(L-1)-1$中的一个,   
例如 `100 -> 99, 99 -> 101`.  
如果L是偶数, 可以把n分为l, r两部分,要寻找最近的回文数,就要使数字变化最小,因此应该从最靠近中间的数位开始变化.  
如果 `l = r[::-1]`, 那么答案是 `(l-1)+(l-1)[::-1]`  
如果 `l != r[::-1]`, 那么答案可能是 `l + l[::-1], (l+1)+(l+1)[::-1], (l-1)+(l-1)[::-1]`  
如果L是奇数,同理,但是数字可以分为`l, mid, r`三部分,要额外考虑只有mid变化的情况.  


```python
def nearestPalindromic(self, n: str) -> str:
    L = len(n)
    if L == 1:
        return str(int(n) - 1)
    candidates = [10**L + 1, 10**(L-1)-1]
    if L%2 == 0:
        l, r = n[:L//2], n[L//2:]
        candidates.append(int(l+l[::-1]))
        l = str(int(l)+1)
        candidates.append(int(l+l[::-1]))
        l = str(int(l)-2)
        candidates.append(int(l+l[::-1]))
    else:
        l, mid,r = n[:L//2], n[L//2], n[L//2 + 1:]
        candidates.append(int(l+mid+l[::-1]))
        if int(mid) < 9:
            candidates.append(int(l+str(int(mid)+1)+l[::-1]))
        if int(mid) > 0:
            candidates.append(int(l+str(int(mid)-1)+l[::-1]))

        l = str(int(l)+1)
        candidates.append(int(l+mid+l[::-1]))
        l = str(int(l)-2)
        candidates.append(int(l+mid+l[::-1]))
    diff = float('inf')
    n = int(n)
    ans = None
    for c in candidates:
        if c != n and abs(c-n) < diff:
            diff = abs(c-n)
            ans = c
        if c != n and abs(c-n) == diff and c < ans:
            ans = c
    return str(ans)
```

#### 231. 2 的幂

```python
def isPowerOfTwo(self, n: int) -> bool:
    return n > 0 and n&(n-1) == 0
```

```python
def isPowerOfTwo(self, n: int) -> bool:
    return n > 0 and (n & -n) == n
```

#### 342. 4的幂

由二项式定理可得
$4^n = (3 + 1)^n = C_n^01 + C_n^1*3 + ... +C_n^n*3^n$
因此 $4\%3 == 1$

```python
def isPowerOfFour(self, n: int) -> bool:
    return n > 0 and n&(n-1) == 0 and n%3 == 1
```

#### 326. 3 的幂

```python
def isPowerOfThree(self, n: int) -> bool:
    while n > 0 and n%3 == 0:
        n = n // 3
    return n == 1           
```

由于题目数据范围不超过$3^{19}$, 可以直接返回 $x\%3^{19} == 0$
```python
def isPowerOfThree(self, n: int) -> bool:
    return n > 0 and 1162261467 % n == 0
```

#### 504. 七进制数

```python
def convertToBase7(self, num: int) -> str:
    if num == 0:
        return '0'
    ans = ''
    flag = False
    if num < 0:
        flag = True
        num = abs(num)
    while num > 0:
        ans = str(num%7) + ans
        num = num//7
    if flag:
        ans = '-' + ans
    return ans
```

#### 263. 丑数
由算术基本定理: 任何大于 1 的整数是质数或独一无二的质数乘积(不理次序)。
因此除到最后如果不是1, 说明可以被其他质数整除
```python
def isUgly(self, n: int) -> bool:
    if n <= 0:
        return False
    for x in [5, 3, 2]:
        while n%x == 0:
            n = n//x
    return n == 1
```

#### 190. 颠倒二进制位
将一个32位二进制数左右颠倒

方法1:
```python
def reverseBits(self, n: int) -> int:
    res = 0
    for _ in range(32):
        res = res << 1
        if n&1:
            res = res | 1
        n = n >> 1
    return res
```

方法二: 分治[参考](https://leetcode.cn/problems/reverse-bits/solution/dian-dao-er-jin-zhi-wei-by-leetcode-solu-yhxz/)
>若要翻转一个二进制串，可以将其均分成左右两部分，对每部分递归执行翻转操作，然后将左半部分拼在右半部分的后面，即完成了翻转。
由于左右两部分的计算方式是相似的，利用位掩码和位移运算，我们可以自底向上地完成这一分治流程。

由于数字一共有32位, 我们可以自底向上地完成递归
首先相邻数字两个一组进行交换
然后相邻数字四个一组进行交换
然后相邻数字八个一组进行交换
最后相邻数字16个一组进行交换

```python
def reverseBits(self, n: int) -> int:
    res = 0''
    M1 = int('01010101010101010101010101010101', 2)
    M2 = int('00110011001100110011001100110011', 2)
    M4 = int('00001111000011110000111100001111', 2)
    M8 = int('00000000111111110000000011111111', 2)
    M16 = int('00000000000000001111111111111111', 2)
    res = ((n&M1) << 1) | ((n >> 1)&M1)
    res = ((res&M2) << 2) | ((res >> 2)&M2)
    res = ((res&M4) << 4) | ((res >> 4)&M4)
    res = ((res&M8) << 8) | ((res >> 8)&M8)
    res = ((res&M16) << 16) | ((res >> 16)&M16)
    return res
```

#### 191. 位1的个数

```python
def hammingWeight(self, n: int) -> int:
    count = 0
    while n:
        n = n&(n-1)
        count += 1
    return count
```

#### 476. 数字的补数
迭代取num的每一位,取反后填入res中
```python
def findComplement(self, num: int) -> int:
    res = 0
    mask = 1
    while mask <= num:
        res = res | (mask ^ (num&mask))
        mask = mask << 1
    return res
```

数字取反后,原来最高位的1一定变为0, 比最高位1更高的位也都是0  
因此直接将数字取反,然后之保留最高位1以后的部分  
举例: '001011' 只保留后3位  
因此要先生成一个保留最高位以后位的mask  
```python
def findComplement(self, num: int) -> int:
    x = num
    while x&(x-1):
        x = x&(x-1)
    return (~num)&(x-1)

```

#### 461. 汉明距离

迭代取每一位,判断
```python
def hammingDistance(self, x: int, y: int) -> int:
    mask = 1
    dis = 0
    for _ in range(32):
        if x&mask != y&mask:
            dis += 1
        mask = mask << 1
    return dis
```

异或,统计1的数量
```python
def hammingDistance(self, x: int, y: int) -> int:
    x = x^y
    dis = 0
    while x:
        if x&1:
            dis += 1
        x = x>>1
    return dis
```

Brian Kernighan 算法:  
优化, 跳过数字中的0, 更快地统计1的数量
```python
def hammingDistance(self, x: int, y: int) -> int:
    x = x^y
    dis = 0
    while x:
        x = x&(x-1)
        dis += 1
    return dis
```

#### 477. 汉明距离总和
给你一个整数数组 nums，请你计算并返回 nums 中任意两个数之间 汉明距离的总和 。

已知是32位整数, 统计每个位为1的个数, 计算.
```python
def totalHammingDistance(self, nums: List[int]) -> int:
    n = len(nums)
    count = [0]*32
    mask = 1
    for i in range(32):
        for num in nums:
            if num&mask == mask:
                count[i] += 1
        mask = mask << 1
    total = 0
    for c in count:
        total += c*(n-c)
    return total
```

#### 693. 交替位二进制数

遍历检查
```python
def hasAlternatingBits(self, n: int) -> bool:
    def other(i):
        return 1 - i
    i = n&1
    while n:
        if n&1 != i:
            return False
        i = other(i)
        n = n >> 1
    return True
```

[利用交叉二进制数的性质](https://leetcode.cn/problems/binary-number-with-alternating-bits/solution/gong-si-shui-by-ac_oier-zuw7/)  
>当给定值 nn 为交替位二进制数时，将 nn 右移一位得到的值 mm 仍为交替位二进制数，且与原数 nn 错开一位，两者异或能够得到形如 0000...1111的结果 x，此时对 x 执行加法（进位操作）能够得到形如 0000...10000的结果，将该结果与x执行按位与后能够得到全 00 结果。


```python
def hasAlternatingBits(self, n: int) -> bool:
    a = n ^ (n >> 1)
    return a & (a + 1) == 0
```

#### 393. UTF-8 编码验证
按规则检查
```python
def validUtf8(self, data: List[int]) -> bool:
    def num_byte(n):
        count  = 0
        for i in range(7, -1, -1):
            if (n >> i)&1:
                count += 1
            else:
                break
        return count

    def check_head(n):
        return (n >> 7)&1 == 1 and (n >> 6)&1 == 0

    n = len(data)
    i = 0
    while i < n:
        c = num_byte(data[i])
        if c > 4 or c == 1:
            return False
        if c > 0:
            for _ in range(1, c):
                i += 1
                if i == n or not check_head(data[i]):
                    return False
        i += 1
    return True
```

#### 172. 阶乘后的零
给定一个整数 n ，返回 n! 结果中尾随零的数量。  
数学法:  
尾随0的数量就是对n!进行因式分解, 能分解出的10的数量.  
而10又可以被分解成质因数2x5.  
根据算数基本定理, 任何数字都可以被分解成质数的积  
因此只要统计n!能分解出多少个2, 记为C2, 能分解出5的数量记为C5, 能分解出10的数量 = `min(C2, C5)`  
由于在区间`[1, n]`中因子5的数量少于因子2的数量,因此只需统计因子5的数量即可.  
显然,只有能被5整除的数字才会有质因数5, 因此不用遍历`[1, n]`,只需遍历5的倍数, `[5, 10, 15, 20, ...]`等  

```python
def trailingZeroes(self, n: int) -> int:
    c5 = 0
    def f5(x):
        if x%5 == 0:
            return 1 + f5(x//5)
        else:
            return 0
    for x in range(5, n+1, 5):
        c5 += f5(x)
    return c5
```

优化: 如何更快地统计出[1, n]中所有数字的质因数5的数量?  
[1, n]之间 5的倍数 有 n//5 个, 5的倍数至少有一个质因数5, 因此它们至少贡献n//5 个质因数5  
[1, n]之间 5^2 的倍数 有 n//(5^2)个, 它们也是5的倍数, 它们至少有两个质因数5, 因此至少贡献2*n//5,除去作为5的倍数贡献的n//5, 它们额外贡献n//5 个 质因数5  
同理, 5^3的倍数也额外贡献 n//5个 质因数5.  
5^i 的倍数也同理.  
只要把每个倍数的贡献相加就能得到质因子5的总数  

```python
def trailingZeroes(self, n: int) -> int:
    def f(n):
        if n == 0:
            return 0
        else:
            return n//5 + f(n//5)
    return f(n)
```
#### 458. 可怜的小猪
数学法()
```python
```

#### 258. 各位相加
方法1:简单递归  
方法2:[数学](https://leetcode.cn/problems/add-digits/solution/ge-wei-xiang-jia-by-leetcode-solution-u4kj/)
自然数的数根(Digital root)  
两个整数a, b若它们除以正整数m所得的余数相等，则称a, b对于模m同余  

```python
```

#### 319. 灯泡开关
数学法  
数论问题  
```python
return int(sqrt(n + 0.5))
```
#### 405. 数字转换为十六进制数
给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。  

进制转换  
给定的数确保在32位有符号整数范围内  
将负数 + 2**32 变成补码  
```python
def toHex(self, num: int) -> str:
    if num == 0:
        return '0'
    if num < 0:
        num += 2**32 
    d = {i:str(i) for i in range(0, 10)}
    for x, y in zip(range(10, 16), 'abcdef'):
        d[x] = y
    res = ''
    while num:
        res += d[num%16]
        num = num//16
    return res[::-1]
```

#### 171. Excel 表列序号
```python
def titleToNumber(self, columnTitle: str) -> int:
    def letter2int(letter):
        return ord(letter) - ord('A') + 1
    res = 0
    mul = 1
    for c in columnTitle[::-1]:
        res += letter2int(c)*mul
        mul *= 26
    return res
```
#### 168. Excel表列名称
和普通的进制转换不同，因为没有0, 所以遇到26的整数倍需要特殊判断.  
例如:  
52 不能用 $52 = 2\times 26^1 + 0 \times 26^0$表示,而是要转化成$52 =1\times 26^1 + 1\times 26^0$  
```python
def convertToTitle(self, columnNumber: int) -> str:
    def num2letter(num):
        return chr(num + ord('A') -1)
    def convert(num):
        if 1 <= num <= 26:
            return num2letter(num)
        else:
            if num%26 == 0:
                return convert((num-26)//26) + 'Z'
            else:
                return convert(num//26) + num2letter(num%26)
    return convert(columnNumber)
```
或者将每一位减一,并让[0, 25]对应'A-Z'
```python
def convertToTitle(self, columnNumber: int) -> str:
    def num2letter(num):
        return chr(num + ord('A'))
    def convert(num):
        if num < 26:
            return num2letter(num)
        else:
            return convert(num//26 - 1) + num2letter(num%26)
    return convert(columnNumber-1)

```

#### 670. 最大交换
给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。  

从最高位开始检查,如果后面有比当前位大的数,将其交换到前面.  
如果后面有两个一样大的数, 优先使用低位的数.  

一种实现,保存第i位后面的最大值的位置, `O(n)`  
```python
def maximumSwap(self, num: int) -> int:
        
    bits = [int(n) for n in str(num)]
    n = len(bits)
    def convert(bits):
        res = 0
        for i in range(n):
            res = res*10 + bits[i]
        return res
    m = [i for i in range(n)]
    for i in range(n-2, -1, -1):
        if bits[m[i+1]] >= bits[i]:
            m[i] = m[i+1]
    for i in range(n):
        t = bits[m[i]]
        if bits[i] != t:
            bits[m[i]], bits[i] = bits[i], t
            return convert(bits)
    return num
```

另一种实现, 保存每种数字最后出现的位置, O(n)  
```python
def maximumSwap(self, num: int) -> int:
        
    bits = [int(n) for n in str(num)]
    n = len(bits)
    def convert(bits):
        res = 0
        for i in range(n):
            res = res*10 + bits[i]
        return res
    last = [-1]*10
    for i, b in enumerate(bits):
        last[b] = i
    for i, b in enumerate(bits):
        for j in range(9, b, -1):
            if last[j] > i:
                bits[i], bits[last[j]] = bits[last[j]], bits[i]
                return convert(bits)
    return convert(bits)
```

#### 233. 数字 1 的个数

数位DP: 针对数字的位进行的DP  
[参考](https://leetcode.cn/problems/number-of-digit-one/solution/gong-shui-san-xie-jiang-shu-wei-dp-wen-t-c9oi/)

枚举每个数位上1能够出现的次数  
举例说明:  
以数字12345为例,  
首先考虑个位.   
假如个位数取1, 由于1小于这一位原来的数字5, 其他位可以取[0000, 1234], 一共1235种取法.  
假如数字是12340, 则其他位只能取[0000, 1233], 一共1234种取法.  
假如十位数取1, 其他高位可以取[000, 122], 个位取[0, 9],一共122*10 中取法. 当高位取123时, 个位可取[0, 9], 一共10中取法.  
假如数字是12305, 则其他高位可以取[000, 122], 个位取[0, 9],一共122*10 中取法. 高位不能取123  

可见,每个数位上1能够出现的次数受到一个因素的影响:  
当前位的数字是否大于1,   
如果是大于1的, 那么将这一位置为1之后数字就会变小, 此时高位只要不大于原来数字即可, 低位则可以任意取.  
如果小于1, 高位的取值必须小于原来，以便使数字小于等于n 低位还是可以随便取  
如果等于1, 高位取原来值时低位必须比原来小, 以便使数字小于等于n  

```python
def countDigitOne(self, n: int) -> int:
    num = str(n)
    L = len(num)
    count = 0
    for i in range(L):
        # 加上'0' 避免了判断边界情况
        pre = '0' + num[:i]
        suf = '0' + num[i+1:]
        # pre val < pre
        count += 10**(L-i-1)*int(pre)
        # pre val == pre
        if int(num[i]) == 0:
            count += 0 
        elif int(num[i]) == 1:
            count += int(suf) + 1
        else:
            count += 10**(L-i-1)
    return count
```

#### 357. 统计各位数字都不同的数字个数
直接构造   
一共有10个数字,因此10位数以上没有各位数字都不同的数字  
1位数有C(9, 1) + 1个(首位可以是0)   
2位数有$C(9, 1)*C(9, 1)$个, 首先在[1 ,9]中选取最高位数字,剩下9个数字任选一个.  
3位数有$C(9, 1)*C(9, 1)*C(8, 1)$个.同理, 先选出最高位,再选其他位.  

```python
def countNumbersWithUniqueDigits(self, n: int) -> int:
    def C(n, m):
        return math.factorial(n)//(math.factorial(n-m)*math.factorial(m)) 
    def count_unique(n):
        if n > 10:
            return 0
        if n == 0:
            return 1
        c = C(9, 1) # chose high bit
        digts = 9
        for i in range(n-1):
            c *= C(digts, 1)
            digts -= 1
        return c
    return sum(count_unique(i) for i in range(n+1))
```
方法2:
数位DP[参考](https://leetcode.cn/problems/count-numbers-with-unique-digits/solution/by-ac_oier-6tfl/)
```python

```

#### 400. 第 N 位数字
给你一个整数 n ，请你在无限的整数序列 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...] 中找出并返回第 n 位上的数字。    

先判断一下序列中的第n位中的数字是由几位数产生的    
假设是m位数, 然后可以取模判断出它是m位数中的第几个数字的第几位    
```python
def findNthDigit(self, n: int) -> int:
    if n <= 9:
        return n
    def count(n):
        return int(n*(10**n - 10**(n-1)))
    total = 0
    i = 1 
    while total + count(i) <= n:
        total += count(i)
        i += 1
    idx = n - total - 1
    x, y = idx//i, idx%i
    return int(str(10**(i-1) + x)[y])
```
### 简单数学题
#### 492. 构造矩形
```python
def constructRectangle(self, area: int) -> List[int]:
    for w in range(int(math.sqrt(area)), 0, -1):
        if area%w == 0:
            return [area//w, w]
```

#### 29. 两数相除
```python
def divide(self, dividend: int, divisor: int) -> int:
    def selfadd(x):
        return x + x

    def mul(x, n):
        if n == 0:
            return 0
        if n%2 == 0:
            return selfadd(mul(x, n//2))
        else:
            return selfadd(mul(x, n//2)) + x

    def div(x, y):
        if x > 0 and y > 0:
            sign = 1
        elif x < 0 and y < 0:
            sign = 1
        else:
            sign = -1
        x = abs(x)
        y = abs(y)
        if x < y:
            return 0, y
        l, r = 0, x+1
        while l < r:
            mid = (l + r)//2
            t = mul(y, mid)
            if t < x:
                l = mid + 1
            elif t == x:
                return mid*sign, 0
            else:
                r = mid
        quotient = l - 1
        remainder = x - mul(y, quotient)
        #print(quotient, remainder, sign)
        return quotient*sign, remainder
    q = div(dividend, divisor)[0]
    if -2**31 <= q <= 2**31 - 1:
        return q
    return 2**31 -1
```

#### 507. 完美数
```python
def checkPerfectNumber(self, num: int) -> bool:
    if num == 1:
        return False
    factors = [1,]
    k = 2
    while k*k < num:
        if num%k == 0:
            factors.append(k)
            factors.append(num//k)
        k += 1
    if k*k == num:
        factors.append(k)
    return sum(factors) == num
```
### 快速幂
#### 50. Pow(x, n)
快速幂的本质是分治法  
递归写法  
```python
def myPow(self, x: float, n: int) -> float:
    def pow(x, n):
        if n == 0:
            return 1
        t = pow(x, n//2)
        if n%2 == 0:
            return t*t
        else:
            return t*t*x
    if n > 0:
        return pow(x, n)
    else:
        return 1/(pow(x, abs(n)))
```
迭代写法[参考](https://leetcode.cn/problems/powx-n/solution/powx-n-by-leetcode-solution/)  
```python
def myPow(x, n):
    def pow(x, n):
        res = 1
        mul = x
        while n:
            if n&1:
                res *= mul
            mul *= mul
            n = n//2
        return res
    if n < 0:
        return 1/pow(x, abs(n))
    return pow(x, n)
```

#### 372. 超级次方
利用数学变换, 把问题变为小规模的子问题  
[参考](https://leetcode.cn/problems/super-pow/solution/chao-ji-ci-fang-by-leetcode-solution-ow8j/)  
```python
def superPow(self, a: int, b: List[int]) -> int:
    M = 1337
    a = a%M
    def pow(a, b):
        if b == 0:
            return 1
        t = pow(a, b//2)%M
        if b%2 == 1:
            return t*t*a%M
        else:
            return (t*t)%M
    res = 1
    for bi in b[::-1]:
        res = res*pow(a, bi)
        res = res%M
        a = pow(a, 10)
    return res

```